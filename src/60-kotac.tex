\Kotac{} is an internal Domain Specific Language for the aggregate programming in Kotlin, currently under development at the address \textit{github.com/kklorenzotesta/KotAC}. Its designed to be fully cross-platform with easy to use idiomatic APIs. Like \Scafi{} the internal DSL offers an easy integration with existing code, and the API has the same semantics of the field calculus. It is also designed to be usable for Android applications. The repository has been integrated with the Travis \cite{Travis} continous integration to validate the pushed builds. The library is built with the Gradle \cite{Gradle} build tool, the standard build tool for Kotlin projects, and linted with the ktlint \cite{ktlint} plugin.

\section{Explicit fields}
Unlike \Scafi{}, in which the fields are implicitly represented in the notion of computation against a neighbour, \Kotac{} explicitly represents the field values with the following interface:
\begin{lstlisting}[language={kotac}]
interface Field<out T> {
    fun <R> map(f: (T) -> R): Field<R>
    fun <R> fold(initial: R, operation: (acc: R, T) -> R): R
}
\end{lstlisting}
$\mathtt{Field}$ is an interface with a covariant\footnote{A class or interface $\mathtt{Foo<T>}$ is covariant in $\mathtt{T}$ if, for each class $\mathtt{B}$ subclass of $\mathtt{A}$, $\mathtt{Foo<B>}$ is subclass of $\mathtt{Foo<A>}$} type parameter $\mathtt{T}$, representing the type of the values to which each device in the field is mapped to. A field exposes only two high level functions for its manipulation. The $\mathtt{map}$ function applies the function $\mathtt{f}$, from $\mathtt{T}$ to $\mathtt{R}$, to each value of the field, obtaining a new field $\mathtt{Field<R>}$. The $\mathtt{fold}$ function allow to reduce a field to a regular local value. Like the \Scafi{} $\mathtt{foldhood}$ the $\mathtt{fold}$ function repeatedly combines the values of the field into an accomulator of type $\mathtt{R}$ by applying the given $\mathtt{operation}$ to each value starting with the value of $\mathtt{initial}$.

Based on this basic operators the \Kotac{} standard library and the users can define new extension functions for the most common operations on fields. For example the built-in operator $\mathtt{anyhood}(\fvalue)$, which evaluates to true if any value of the field is true, can be defined as:
\begin{lstlisting}[language={kotac}]
fun Field<Boolean>.any(): Boolean = this.fold(true) { acc, v -> acc || v  }
\end{lstlisting}

A concrete implementation of field has been defined only for internal use. The implementation is backed by an immutable $\mathtt{Map}$ associating $\mathtt{DeviceID}$s to the values. The implementation is not part of the public API, disallowing arbitrary manipulations of fields data that may alter the semantics.

$\mathtt{DeviceID}$ is an empty interface representing an identifier for a device. Two implementations are provided, one based on integer identifiers and one based on string identifiers.

\section{Basic operators}

The API for the field calculus operators are defined inside the interface $\mathtt{AggregateContext}$:
\begin{lstlisting}[language={kotac}]
interface AggregateContext {
    fun <T> share(initial: T, f: (Field<T>) -> T): T
    fun <K, T> align(key: K, proc: (K) -> T): T
    fun <T> nbr(f: () -> T): Field<T>
    fun <T> rep(initial: T, f: (T) -> T): T
}
\end{lstlisting}
The $\mathtt{share}$ function implements the share operator of the field calculus, which at each execution applies the neighbouring field of the last computed value to the function $\mathtt{f}$, starting with the $\mathtt{initial}$ value for the executing device. The function $\mathtt{align}$ executes the function $\mathtt{proc}$ aligning to the devices with the same value of $\mathtt{key}$. The function $\mathtt{nbr}$ implements the nbr operator of the field calculus, running the function $\mathtt{f}$ for the executing device and returning a neighbouring field with the last values. The function $\mathtt{rep}$ implements the rep operator of the field calculus, which, starting from $\mathtt{initial}$ applies the last computed value to $\mathtt{f}$.

Aggregate programs can then be written as extension function of $\mathtt{AggregateContext}$, allowing to call the operators just like keywords. For example the following code:
\begin{lstlisting}[language={kotac}]
fun AggregateContext.rounds(): Int = rep(0) { x -> x + 1 }
\end{lstlisting}
defines an aggregate program called $\mathtt{rounds}$ which counts the number of rounds that has been executed, if called at every round on the same $\mathtt{AggregateContext}$.

\section{Internal implementation}
The $\mathtt{ConcreteAggregateContext}$ class implements the $\mathtt{AggregateContext}$ interface providing the implementation of all the operators. 

Internally the $\mathtt{Trace}$ interface represents an immutable point in the execution that will be use for the alignments,  it doesn't defines any methods but its used only for equality. The interface $\mathtt{Stack}$ is defined as:
\begin{lstlisting}[language={kotac}]
interface Stack {
    fun enter(align: Any)
    fun exit()
    val trace: Trace
}
\end{lstlisting}
It offers methods to manage the creating of $\mathtt{Trace}$s. The $\mathtt{enter}$ and $\mathtt{exit}$ methods are called by the operators to update che current $\mathtt{Trace}$, the method $\mathtt{trace}$ returns then a new instance of $\mathtt{Trace}$ based on the previous invocations of $\mathtt{enter}$ and $\mathtt{exit}$.

The internal state of a $\mathtt{ConcreteAggregateContext}$ is kept in the data structures $\mathtt{ValueTree}$ and $\mathtt{ValueEnvironment}$. A $\mathtt{ValueTree}$ is an interface defined as:
\begin{lstlisting}[language={kotac}]
interface ValueTree {
    fun get(trace: Trace): Any?
    fun put(trace: Trace, value: Any?)
}
\end{lstlisting}
The inferface describes a basic mutable $\mathtt{Map}$ from $\mathtt{Trace}$s to values of any type. Since values are absent in non aligned devices the returned values are nullable.
A $\mathtt{ValueEnvironment}$ is an interface defined as:
\begin{lstlisting}[language={kotac}]
interface ValueEnvironment {
    fun getTree(device: DeviceID): ValueTree
    fun putTree(device: DeviceID, tree: ValueTree)
}
\end{lstlisting}
The interface describes a basic mutable $\mathtt{Map}$ from $\mathtt{DeviceID}$s to $\mathtt{ValueTree}$s.
Both $\mathtt{ValueTree}$ and $\mathtt{ValueEnvironment}$ are not designed to be accessed by application developers, but instead to be managed by the basic operators. Therefore their API will be modified according to the needs of the internals.

The $\mathtt{ConcreteAggregateContext}$ contains then a field named $\mathtt{localTree}$ which is a $\mathtt{ValueTree}$ in which are stored the data for the local interactions, i.e. the rep operator. Another field named $\mathtt{neighboringTree}$ is a $\mathtt{ValueTree}$ in which are stored the data for the neighbouring interactions, i.e. the share and nbr operators, this tree will be sent to the neighbours. Finally a field named $\mathtt{neighboringEnvironment}$ is a $\mathtt{ValueEnvironment}$ holding all the last $\mathtt{ValueTree}$s sent by the neighbours.

\section{\Kotac semantics}

\begin{figure}[t]
\centering
\centerline{$
\begin{array}{l@{\hspace{1mm}}c@{\hspace{1mm}}l@{\hspace{-8mm}}r}
        \PROGRAM & \BNFcce & \overline{\FUNCTION}  \; \e
                                                                                                                                                                                                        &   {\footnotesize \mbox{program}} \\[3pt]
        \FUNCTION & \BNFcce &  \funK \; \fname (\overline{\xname}) \; \{ \alignK(\fname){\{\e\}} \}
                                                                                                                                                                                                        &   {\footnotesize \mbox{function declaration}} \\[3pt]
        \e & \BNFcce & \xname \, \BNFmid \, \anyvalue \, \BNFmid \, \e(\overline{\e}) \, \BNFmid \, \repK(\e)\{ (\xname) \ftoSym \e \} \, \BNFmid \, \nbrK\{\e\} \, \BNFmid \, \shareK(\e)\{(\xname) \ftoSym \e \} \,
                                                                                                                                                                                                        &   {\footnotesize \mbox{expression}} \\[3pt]
        \hline \\[-6pt]
                \anyvalue & \BNFcce &  \lvalue \; \BNFmid \; \fvalue
                &{ \mbox{\footnotesize value}}
                \\[3pt]
              \lvalue & \BNFcce &  \dcOf{\dc}{\overline\lvalue} \; \BNFmid \; \funvalue
                &{ \mbox{\footnotesize local value}}
                \\[3pt]
                \fvalue & \BNFcce &  \envmap{\overline\deviceId}{\overline\lvalue}
                &{ \mbox{\footnotesize neighbouring field value}} \\
        \funvalue & \BNFcce & \bname \; \BNFmid \; \fname \; \BNFmid \; (\overline{\xname}) \; \toSym{\name}{\{\alignK(\name)\{\e\}\}}
                                                                                                                                                                                                        &   {\footnotesize\mbox{function value}} \\
\end{array}
$
}
\caption{Syntax of \FKotac{}}
\label{fig:fkotacsyntax}
\end{figure}

In order to formalize the semantic of \Kotac{} a subset of it has been considered called \textit{Featherweight \Kotac{} (\FKotac{})} . The syntax of \FKotac is shown in figure \ref{fig:fkotacsyntax}, it focus on the aggregate constructs ignoring the Kotlin specific features. A program $\PROGRAM$ is a sequence of function declarations $\overline{\FUNCTION}$ followed by a main expression $\e$. A function declaration $\FUNCTION$ defines a (possibly recursive) function named $\fname$, with a sequence of formal parameters $\overline{\xname}$ and a body expression $\e$. An expression $\e$ can be a variable $\xname$, a value $\anyvalue$, a function application $\e(\overline{\e})$ where $\e$ evaluates to a function $\funvalue$ and $\overline{\e}$ are the arguments, a $\mathtt{rep}$-expression $\repK(\e)\{ \e \}$ modelling time evolution, a $\mathtt{nbr}$-expression $\nbrK\{\e\}$ modelling neighbourhood interaction or a $mathtt{share}$-expression $\shareK(\e)\{(\xname) \ftoSym \e \}$ modelling time evolution based on a neighbouring field.

A value can be either a local value $\lvalue$ or a neighbouring field value $\fvalue$. Neighbouring field values doesn't appear in the source code but can only be computed dynamically, usally by built-in operators like $\mathtt{nbr}$ or $\mathtt{share}$.

Local values can be either data value $ \dcOf{\dc}{\overline\lvalue}$, in which $\dc$ is a data constructor and $\overline{\lvalue}$ are local value arguments, or a function value $\funvalue$.

A function value $\funvalue$ can be a built-in function $\bname$, a declared function $\fname$ or an anonymous function value $\toSym{\name}{\{\alignK(\name)\{\e\}\}}$, where $\overline{\xname}$ are variable names for the formal parameters, $\e$ is the body of the function and $\name$ is a \textit{tag} that uniquely identifies the function and doesn't occours in the source program.

\begin{figure}[!t]{
 \scalebox{0.85}{
 $\begin{array}{l}
 \textbf{Value-trees and value-tree environments:}\\
\begin{array}{lcl@{\hspace{6.8cm}}r}
%
\vtree & \BNFcce &  \mkvt{\anyvalue}{\overline{\vtree}}    &   {\footnotesize \mbox{value-tree}} \\
\Trees & \BNFcce & \envmap{\overline{\deviceId}}{\overline{\vtree}}   &   {\footnotesize \mbox{value-tree environment}}
%
\end{array}\\[10pt]
\hline\\[-8pt]
%%%%  AUX
\textbf{Auxiliary functions:}\\
\begin{array}{l}
\begin{array}{l@{\hspace{1cm}}l}
%
\vrootOf{\mkvt{\anyvalue}{\overline{\vtree}}}  =   \anyvalue
\\
%
\piIof{i}{\mkvt{\anyvalue}{\vtree_1,\ldots,\vtree_n}}  =   \vtree_i
\quad \mbox{if} \; 1\le i \le n
\\
\piBof{\funvalue}{\mkvt{\anyvalue}{\vtree_1,\ldots,\vtree_{n+1}}}  =   \vtree_{n+1}
\quad \mbox{if} \; \funvalue \; \mbox{is a built-in function and} \; \vrootOf{\vtree_{n+1}} = \funvalue
\\
\piBof{\funvalue}{\mkvt{\anyvalue}{\vtree_1,\ldots,\vtree_{n+2}}}  =   \vtree_{n+2}
\quad \mbox{if} \; \funvalue \; \mbox{is a non-built-in function and} \; \nameOf(\vrootOf{\vtree_{n+1}}) = \nameOf(\funvalue)
\\
 \piBof{\funvalue}{\vtree}  =   \emptyseq \quad \mbox{otherwise}
\\  
\end{array}
\\
\mbox{For } \auxNAME\in\rho,\piI{i},\piB{\funvalue}:
\quad 
\left\{\begin{array}{lcll}
 \aux{\envmap{\deviceId}{\vtree}, \Trees}  & =  & \envmap{\deviceId}{\aux{\vtree}}, \aux{\Trees} & \quad \mbox{if} \; \aux{\vtree} \not=\emptyseq  
\\
\aux{\envmap{\deviceId}{\vtree}, \Trees}  & =   & \aux{\Trees} & \quad \mbox{if} \; \aux{\vtree}=\emptyseq  
\\
\aux{\emptyseq}  & =  &  \emptyseq
\end{array}\right.   
\\
\begin{array}{ll}
\nameOf(\fname) = \fname 
& 
\args{\fname} = \overline{\xname} \quad \mbox{if } \, \funK \; \fname (\overline{\xname}) \; \{ \alignK(\fname){\{\e\}} \}
\\
\body{\fname} = \e  \quad \mbox{if } \, \funK \; \fname (\overline{\xname}) \; \{ \alignK(\fname){\{\e\}} \}
&
\nameOf(\overline{\xname}) \; \toSym{\name}{\{\alignK(\name)\{\e\}\}}) = \name
\\
\args{(\overline{\xname}) \; \toSym{\name}{\{\alignK(\name)\{\e\}\}}} = \overline{\xname}
&
\body{(\overline{\xname}) \; \toSym{\name}{\{\alignK(\name)\{\e\}\}}} = \e
\end{array}
\\
\begin{array}{l@{\hspace{0.4cm}}l}
		\fvalue_0[\fvalue_1] = \fvalue_2 \; \text{ where } \fvalue_2(\deviceId) = \left\lbrace \begin{array}{ll}
			\fvalue_1(\deviceId) & \text{if } \deviceId \in \domof{\fvalue_1} \\
			\fvalue_0(\deviceId) & \text{otherwise}
		\end{array} \right. \\
\end{array}
\end{array}\\
\hline\\[-10pt]
\textbf{Syntactic shorthands:}\\
\begin{array}{l@{\hspace{5pt}}l@{\hspace{5pt}}l}
\bsopsem{\deviceId}{\piIofOv{\Trees}}{\senstate}{\overline{\e}}{\overline{\vtree}}
&
  \textrm{where~~} |\overline{\e}|=n
&
  \textrm{for~~}
  \bsopsem{\deviceId}{\piIof{1}{\Trees}}{\senstate}{\e_1}{\vtree_1}
    \cdots
    \bsopsem{\deviceId}{\piIof{n}{\Trees}}{\senstate}{\e_n}{\vtree_n} \!\!\!\!\!\!\!\!\!\!\!\! \\
\vrootOf{\overline{\vtree}}
&
  \textrm{where~~} |\overline{\vtree}|=n
  & \textrm{for~~}
\vrootOf{\vtree_1},\ldots,\vrootOf{\vtree_n}\\
\substitution{\overline{\xname}}{\vrootOf{\overline{\vtree}}}
&   \textrm{where~~} |\overline{\xname}|=n
  &
  \textrm{for~~}
\substitution{\xname_1}{\vrootOf{\vtree_1}}~\ldots\quad\substitution{\xname_n}{\vrootOf{\vtree_n}}
\end{array}\\
\hline\\[-10pt]
%%%  EVALUATION RULES
\textbf{Rules for expression evaluation:} \hspace{4.4cm} %\hfill
%\vspace{-0.2cm}
  \boxed{\bsopsem{\deviceId}{\Trees}{\senstate}{\e}{\vtree}}
\skiptransition%[-5pt]
\begin{array}{c}
%\vspace{-0.1cm}
\nullsurfaceTyping{E-LOC}{
\bsopsem{\deviceId}{\Trees}{\senstate}{\lvalue}{\mkvt{\lvalue}{}}
}
\qquad\qquad
\surfaceTyping{E-FLD}{\qquad \fvalue' = \proj{\fvalue}{\domof{\Trees}\cup\{\deviceId\}}}{
\bsopsem{\deviceId}{\Trees}{\senstate}{\fvalue}{\mkvt{\fvalue'}{}}
}
\skiptransition\\[-6pt]
\surfaceTyping{E-B-APP}{  \quad
\begin{array}{c}
  \bsopsem{\deviceId}{\piIofOv{\Trees}}{\senstate}{\overline{\e},\e}{\overline{\vtree},\vtree}
  \qquad \bname=\vrootOf{\vtree}
  \qquad \anyvalue=\builtinop{\bname}{\correction{\deviceId}}{\piBof{\bname}{\Trees},\senstate}(\vrootOf{\overline{\vtree}})
\end{array}
 }{
\bsopsem{\deviceId}{\Trees}{\senstate}{\e(\overline{\e})}{\mkvt{\anyvalue}{\overline{\vtree},\vtree}}
}
%
\skiptransition\\[-6pt]
%
\surfaceTyping{E-D-APP}{ \quad
\begin{array}{c}
  \bsopsem{\deviceId}{\piIofOv{\Trees}}{\senstate}{\overline{\e},\e}{\overline{\vtree},\vtree} \qquad 
  \funvalue=\vrootOf{\vtree} \mbox{is not a built-in} \qquad
\\
  \bsopsem{\deviceId}{\piBof{\funvalue}{\Trees}}{\senstate}{\applySubstitution{\body{\funvalue}}{\substitution{\args{\funvalue}}{\vrootOf{\overline{\vtree}}}}}{\vtree'}
\end{array}
 }{
\bsopsem{\deviceId}{\Trees}{\senstate}{\e(\overline{\e})}{\mkvt{\vrootOf{\vtree'}}{\overline{\vtree},\vtree,\vtree'}}
}
%
\skiptransition\\[-5pt]
\surfaceTyping{E-NBR}{
         \qquad
     \Trees_1=\piIof{1}{\Trees} \qquad
     \bsopsem{\deviceId}{\Trees_1}{\senstate}{\e}{\vtree_1}
\qquad
 \fvalue=\mapupdate{\vrootOf{\Trees_1}}{\envmap{\deviceId}{\vrootOf{\vtree_1}}}
 }{
\bsopsem{\deviceId}{\Trees}{\senstate}{\nbrK\{\e\}}{\mkvt{\fvalue}{\vtree_1}}
}
\skiptransition\\[-6pt]
\surfaceTyping{E-REP}{
        \quad
        \begin{array}{l}
     \bsopsem{\deviceId}{\piIof{1}{\Trees}}{\senstate}{\e_1}{\vtree_1} \\
     \bsopsem{\deviceId}{\piIof{2}{\Trees}}{\senstate}{\applySubstitution{\e_2}{\substitution{\xname}{\lvalue_0}}}{\vtree_2}~~
        \end{array}
        \quad
        \lvalue_0 \! = \!\left\{\begin{array}{ll}
                             \vrootOf{\piIof{2}{\Trees}}(\deviceId) & \mbox{if} \;  \deviceId \in \domof{\Trees} \\
                             \vrootOf{\vtree_{1}} & \mbox{otherwise}
                           \end{array}\right.
 }{
\bsopsem{\deviceId}{\Trees}{\senstate}{\repK(\e_1)\{(\xname) \; \ftoSym \; \e_2\}}{\mkvt{\vrootOf{\vtree_{2}}}{\vtree_1,\vtree_2}}
}
\skiptransition\\[-4pt]
\surfaceTyping{E-SHARE}{ \qquad
	\begin{array}{l@{\hspace{0.5em}}l}
     \bsopsem{\deviceId}{\piIof{1}{\Trees}}{{\senstate}}{\e_1}{\vtree_1} & \fvalue' = \vrootOf{\piIof{2}{\Trees}} 
      \qquad \qquad \fvalue = (\envmap{\deviceId}{\vrootOf{\vtree_1}})[\fvalue']
     \\
     \bsopsem{\deviceId}{\piIof{2}{\Trees}}{{\senstate}}{\applySubstitution{\e_2}{\substitution{\xname}{\fvalue}}}{\vtree_2} %& \fvalue = (\envmap{\deviceId}{\vrootOf{\vtree_1}})[\fvalue']
	\end{array}
	\!\!\!\!
 }{
	\bsopsem{\deviceId}{\Trees}{\senstate}{\shareK(\e_1)\{(\xname) \; \ftoSym \; \e_2\}}{\mkvt{\vrootOf{\vtree_{2}}}{\vtree_1,\vtree_2}}
}
\end{array}
\end{array}$
}
}
 \caption{Big-step operational semantics of \FKotac{}.} \label{fig:kotacSemantics}
\end{figure}

Figure \ref{fig:kotacSemantics} shows the operational semantics of the syntax.It follows the same notation of the field calculus semantics and uses the same auxiliary functions. Rules \ruleNameSize{[E-LOC]} e \ruleNameSize{[E-FLD]} define the evaluation fo local values and neighbouring values, both producing a value-tree with no subtrees, with a domain restriction to the aligned devices in case of neighbouring fields. Rules \ruleNameSize{[E-B-APP]} and \ruleNameSize{[E-D-APP]} model the application of built-in and user defined (or anonymous) functions, the former based on a function different for each built-in and the latter by executing the body of the function. Rule \ruleNameSize{[E-NBR]} models the evaluation of $\mathtt{nbr}$-expressions, by extracting from the value-tree environment the neighbouring values to build a neighbouring field, and computing the expressions $\e$ for the new value of the executing device. Rule \ruleNameSize{[E-REP]} models the evauation of $\mathtt{rep}$-expressions, by extracting from the value-tree environemtn the last computed value for the new evaluation of $\e$. Rule \ruleNameSize{[E-SHARE]} models the evaluation of $\mathtt{share}$-expressions, by constructing a field of the last computing values as the argument $\xname$ for the evaluation of $\e_2$ and using $\e_1$ as the initial value of the executing device.

\begin{figure}[!t]{
 $\begin{array}{l}
 %%%  SYNTAX
 \textbf{System configurations and action labels:}\\
\begin{array}{lcl@{\hspace{7.5cm}}r}
%
\Field & \BNFcce &  \envmap{\overline\deviceId}{\overline\Trees}    &   {\footnotesize \mbox{status field}} \\
\Topo & \BNFcce &  \envmap{\overline\deviceId}{\overline\devset}    &   {\footnotesize \mbox{topology}} \\
\Sens & \BNFcce &  \envmap{\overline\deviceId}{\overline\senstate}    &   {\footnotesize \mbox{sensors-map}} \\
\Envi & \BNFcce &  \EnviS{\Topo}{\Sens}    &   {\footnotesize \mbox{environment}} \\
\Cfg & \BNFcce &  \SystS{\Envi}{\Field}    &   {\footnotesize \mbox{network configuration}} \\
\act & \BNFcce &  \deviceId \;\BNFmid\; \envact    &   {\footnotesize \mbox{action label}} \\
%
\end{array}\\
\hline\\[-8pt]
\textbf{Environment well-formedness:}\\
\begin{array}{l}
%
\wfn{\EnviS{\Topo}{\Sens}} \textrm{~~holds iff {$\domof{\Topo}=\domof{\Sens}$ and $\Topo(\deviceId) \subseteq \domof{\Sens}$ for all $\deviceId \in \domof{\Sens}$.}}
\\
\end{array}\\
\hline\\[-8pt]
%%%%%%%%%%
%%%  REDUCTION RULES
\textbf{Transition rules for network evolution:} \hfill
  \boxed{\nettran{\Cfg}{\act}{\Cfg}}
  \\[0.2cm]
\vspace{0.5cm}
\begin{array}{c}
\netopsemRule{N-FIR}
                 {\quad \Envi=\EnviS{\Topo}{\Sens}
                   \quad \Topo(\deviceId)= \overline\deviceId 
                  \quad {\bsopsem{\deviceId}{\filter(\Field)(\deviceId)}{\Sens(\deviceId)}{\emain}{\vtree}}
                  \quad
                 \Field_1=\envmap{\overline\deviceId}{\{\envmap{\deviceId}{\vtree}\}}}
                 {\nettran{\SystS{\Envi}{\Field}}{\deviceId}{\SystS{\Envi}{\mapupdate{\filter(\Field)}{\Field_1}}}%\nopsem{\EnviS{\Topo}{\Sens}}{\Field}{\deviceId}{\mapupdate{\Field}{\deviceId}{\vtree}}
                 }
\skiptransition
\netopsemRule{N-ENV}
                 {\qquad \wfn{\Envi'}\qquad \Envi'=\EnviS{\Topo}{\envmap{\overline\deviceId}{\overline\senstate}} \qquad
                  %\bsopsem{\senstate_1}{\emptyset}{\emain}{\vtree_1}\quad\cdots\quad\bsopsem{\senstate_n}{\emptyset}{\emain}{\vtree_n} \qquad
                  \Field_0=\envmap{\overline\deviceId}{\emptyset}
                 }
                 {\nettran{\SystS{\Envi}{\Field}}{\envact}{\SystS{\Envi'}{\mapupdate{\Field_0}{\Field}}}
                 }\\[-10pt]
\end{array}\\
%\textbf{Initial device state $\initialvtree$:}\\[0.2cm]
%\begin{array}{c}
%
%\qquad\qquad\netopsemRule{Init}
%                 {\senstate_0(\snsname)=\initialOf{\typeof{\snsname}}}
%                 {\bsopsem{\senstate_0}{\emptyset}{\emain}{\initialvtree}}
%
%\end{array}
%
\end{array}$
} %%%\capskip
 \caption{Small-step operational semantics for network evolution.} \label{fig:kotacnetworkSemantics}
\end{figure}

Figure \ref{fig:kotacnetworkSemantics} defines the operational semantics of whole networks. It uses the same syntax of the field calculus network semantics and the same rules. Like for the field calculus rule \ruleNameSize{[N-FIR]} models a computational round on device $\deviceId$ and rule \ruleNameSize{[N-ENV]} models an environement change to a new well-formed environment.